# 电影脚本长度（固定条数）后端改造开发清单

## 范围与目标（仅后端）
- 将电影解说的“脚本长度”从“短篇/中偏/长偏（按比例裁剪）”改为“固定条数范围（按条数规划模型调用次数）”
- 按用户选择的目标条数范围规划模型调用次数，并将字幕按条数切分为多个子任务（Map），再合并（Reduce）并统一润色（Refine）
- 同时满足模型输入限制（单次模型输入字幕条数上限）与输出限制（单次模型输出条数上限）
- 全流程保持可维护性：新增独立纯函数/工具函数封装“规划与切分逻辑”，避免把复杂逻辑堆在主流程里

## 新旧逻辑对比（改造依据）
- 旧逻辑（现状）
  - 项目字段：`script_length = "短篇" | "中偏" | "长偏"`
  - 生成逻辑：以视频总时长为依据做滑动时间窗口分块（`WINDOW_SIZE=2000` 秒，`OVERLAP=60` 秒），并在 Refine 阶段按比例裁剪条目数（1/3、2/3、全部）
- 新逻辑（目标）
  - 项目字段：保存“目标条数范围”选择（例如 `15～20条`、`30～40条` …）
  - 生成逻辑：以“目标条数范围 ⇒ 规划模型调用次数”作为主驱动；以“字幕条数上限 ⇒ 决定是否进一步拆分/递归拆分”作为约束

## 关键约束与规则（必须在后端兜底）
- 输出约束（单次模型调用的输出上限）
  - 15～20 条 = 1 次模型调用
  - 30～40 条 = 2 次模型调用
  - 40～60 条 = 3 次模型调用
  - 60～80 条 = 4 次模型调用
  - 80～100 条 = 5 次模型调用
- 输入约束（单次模型调用的字幕输入条数上限）
  - 单次模型输入字幕条数不得超过 `MAX_SUBTITLE_ITEMS_PER_CALL=2000`
  - 若字幕条数超过 2000 但小于 `2000*1.8`，允许不拆分（作为“软上限”兼容策略）
  - 若超过 `2000*1.8`，必须拆分为多次模型调用；拆分后每次输出条数需按总目标条数均分（例如 15～20 拆成 2 次则每次 7～10 条）
- 强制输出条数（系统提示词必须约束）
  - Map 阶段：每个子调用必须强制输出指定条数（不允许多/少）
  - Refine 阶段：合并后再次强制输出“最终目标条数”（同样不允许多/少）

## 数据结构与接口契约改造

### 1) 项目字段（ProjectsStore / Project）
- 保持字段名不变的最小改造方案
  - 继续使用 `script_length` 字段存储用户选择，但将可选值从 `"短篇/中偏/长偏"` 替换为 `"15～20条" | "30～40条" | "40～60条" | "60～80条" | "80～100条"`
  - 好处：路由/存储改动最小；前端仅需更新展示与枚举
  - 风险：历史语义不一致，需要做兼容映射（见“兼容与迁移”）
- 推荐的可维护方案（可选，但建议）
  - 新增字段：`script_target_items: Optional[int]` 或 `script_target_range: Optional[str]`
  - 将 `script_length` 保留为兼容字段（读取时优先新字段）
  - 好处：语义清晰，避免将“长度”与“条数”混在一个字段里

### 2) UpdateProjectRequest 与校验
- `backend/routes/project_routes.py` 的 `UpdateProjectRequest.script_length` 现为 `Optional[str]`
  - 改造：增加后端校验/归一化（允许旧值与新值；落盘时写成规范化新值或写到新字段）
  - 统一规范：前端传值必须是固定集合之一（建议后端用枚举/白名单兜底校验）

## 脚本生成流程改造（核心）

### 3) 新增：条数模式解析与规划（独立封装函数）
- 新增纯函数（建议放 `script_generation_service.py` 末尾或独立模块）
  - `parse_script_length_selection(value: Optional[str]) -> ScriptTargetPlan`
  - `ScriptTargetPlan` 建议包含：
    - `target_min` / `target_max`
    - `preferred_calls`（1~5）
    - `final_target_count`（最终强制输出条数，需明确取值策略：上限/下限/中位数/可配置）
- 兼容：当读取到旧值 `"短篇/中偏/长偏"` 时，映射到一个默认范围（需产品确认并固化为后端常量）

### 4) 新增：字幕切分规划（独立封装函数）
- 目标：输入字幕数组，输出“若干个子任务”，每个子任务包含字幕切片与该次需要输出的条目数
- 推荐函数拆分
  - `compute_subtitle_chunks(subtitles, desired_calls, max_items, soft_factor) -> List[SubtitleChunk]`
  - `split_chunk_if_oversize(chunk, max_items, soft_max_items) -> List[SubtitleChunk]`
  - `allocate_output_counts(total_target_count, chunk_count) -> List[int]`
- 关键行为要求
  - 首先按用户选择得到基础 calls（1~5），按 calls 均分字幕为 calls 段
  - 对每段进行“输入上限校验”，超过 `soft_max_items=max_items*1.8` 则递归拆分
  - 若因输入过大导致 chunk 数增加，必须同步重分配每次输出条数，并保证最终 Refine 仍输出 `final_target_count`

### 5) Map 阶段：每段强制输出指定条数
- 改造 `ScriptGenerationService._generate_script_json_simple` / `_generate_script_chunk`
  - 允许传入 `target_items_count`（该次模型必须输出的条数）
  - 在系统提示词中写入硬约束（“必须输出 N 条，不能多不能少”）
- 提示词注入策略（两种二选一）
  - 方案 A：保持现有 prompt 模板不动，在 messages 前额外插入一条 system message 进行数量约束
  - 方案 B：给 prompt 模板增加变量占位符（例如 `${target_items_count}`），由 prompt_manager 注入

### 6) Reduce 阶段：合并与去重（复用但需对齐新目标）
- 继续使用现有 `_merge_items()` 合并 Map 结果
- 需要新增一次“合并结果校验”
  - 若合并后条目数远小于最终目标条数：记录告警并走降级策略（例如允许 Refine 做补齐或直接放宽最终条数约束）
  - 若合并后条目数远大于最终目标条数：交给 Refine 阶段裁剪（但必须裁剪到 `final_target_count`）

### 7) Refine 阶段：按最终目标条数强制输出
- 改造 `_refine_full_script` 的入参语义
  - 从 `length_mode: "短篇/中偏/长偏"` 改为 `target_count: int`（或 `target_min/max + strategy`）
  - 由上层在进入 Refine 前完成“最终目标条数”的决策
- Refine 的系统提示词必须显式强制条数
  - 返回的 `items` 长度必须为 `target_count`，不得新增条目，仅能从已有 `_id` 中选择
  - 保留“不能烂尾”的约束与“原声/解说比例”等约束

### 8) 处理“15～20条但字幕过长”的特殊分支
- 规则要求
  - 默认 1 次调用；但当字幕条数超过 `soft_max_items` 时拆分为 2 次（或更多次）
  - 拆分后每次输出 7～10 条，合并后 Refine 输出 15～20 条（按最终目标条数策略）
- 需要实现的通用机制
  - 让“desired_calls”在输入过大时可被提升（至少能从 1 提升到 2）
  - 每次输出条数分配必须与最终目标一致（避免最后无法裁剪到精确条数）

## 常量与命名整理（避免混淆）
- 当前 `WINDOW_SIZE=2000` 在代码里用于“秒”为单位的时间窗
- 新需求中的 `WINDOW_SIZE=2000` 是“字幕条数上限”的语义
- 改造要求
  - 引入并统一使用清晰命名的常量（例如 `TIME_WINDOW_SECONDS`、`MAX_SUBTITLE_ITEMS_PER_CALL`、`SOFT_INPUT_FACTOR`）
  - 确保任何“条数”相关判断不再复用“秒数窗口”常量

## 兼容与迁移策略
- 历史项目兼容
  - 读取到旧值 `"短篇/中偏/长偏"` 时，后端进行映射为新范围（需确认映射表并固化）
  - 返回给前端时可以直接返回映射后的新值（让前端不必处理旧值），或返回原值但提供 `effective_script_length`（二选一，需统一）
- 接口兼容
  - `UpdateProjectRequest.script_length` 暂保持 `string`，但后端必须做白名单校验与归一化
  - `ProjectsStore.update_project()` 只在 `updates[key] is not None` 时写入，注意允许显式清空字段的产品需求（若需要支持清空，需额外约定）

## 异常处理与降级策略
- 输入字幕为空/解析失败：保持现有 400 错误
- 模型调用失败（单段失败 / 部分段失败）
  - 需要明确：是否允许部分成功继续（建议允许并记录告警），还是整体失败回滚（建议与产品确认）
- 输出条数不满足强约束
  - 若模型未遵守“必须输出 N 条”：增加后处理校验与重试策略（最多重试次数、回退到放宽约束）

## 自测清单（后端）
- 基础正确性
  - 选择 `15～20条`：字幕未超软上限时只调用 1 次 Map；Refine 输出固定目标条数
  - 选择 `80～100条`：基础 calls=5；Refine 输出固定目标条数
- 输入限制分支
  - 选择 `15～20条` 且字幕条数 > `soft_max_items`：自动拆成 2 段；每段输出 7～10；Refine 输出最终目标条数
  - 选择 `80～100条` 且任一段字幕条数仍超 `soft_max_items`：触发递归拆分；仍能输出最终固定条数
- 兼容分支
  - 历史项目 `script_length="短篇"`：映射到新范围并正常生成
- 输出校验
  - Map/Refine 的返回 JSON 能通过 `validate_script_items`
  - 最终 `items` 条数严格等于目标条数（或在约定的范围内，取决于最终策略）

