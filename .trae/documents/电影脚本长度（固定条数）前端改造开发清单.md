# 解说脚本条数（固定条数）前端改造开发清单

## 范围与目标（仅前端）
- 将“解说脚本条数”改为“固定条数范围”选择，面向用户可理解且可预期（电影解说、短剧解说都适用）
- 将用户选择持久化到项目配置，并在重新进入编辑页时正确回显
- 按工程化原则拆分：把页面 `useEffect` 中的请求逻辑抽成独立函数/自定义 hook，降低耦合

## 当前前端现状（作为改造依据）
- 入口组件：`frontend/src/components/projectEdit/GenerateAdvancedConfigSection.tsx`
  - 当前仅当 `narrationType === "电影解说"` 时展示“电影脚本长度”单选框（需改为电影/短剧都展示）
  - 通过 `projectService.getProject(projectId)` 拉取 `script_length` 回显
  - 用户切换时调用 `projectService.updateProject(projectId, { script_length: len })` 写回
- 类型定义：`frontend/src/types/project.ts`
  - `ScriptLengthOption = "短篇" | "中偏" | "长偏"`
  - `Project.script_length?: ScriptLengthOption`

## 后端契约（前端需要对齐）
- 项目字段：`script_length`
  - 新可选值建议为固定集合（示例）：
    - `"15～20条"` / `"30～40条"` / `"40～60条"` / `"60～80条"` / `"80～100条"`
  - 注意：后端更新接口会校验 `script_length`，旧值会被拒绝；前端必须在写回前完成归一化
  - 默认：当项目未设置或是历史脏值时，后端生成会回退到默认值（建议前端默认也用 `30～40条`）
- 更新接口：`POST /api/projects/{project_id}`（现有 updateProject 绑定的接口）
  - 前端写回必须只写“后端认可的值”（白名单），否则会 400

## 类型与枚举改造

### 1) 更新 ScriptLengthOption 定义
- 文件：`frontend/src/types/project.ts`
- 任务：
  - 将 `ScriptLengthOption` 改为新固定集合
  - 视兼容期需要，额外定义 `LegacyScriptLengthOption = "短篇" | "中偏" | "长偏"`
  - `Project.script_length` 的类型策略二选一（需统一）
    - 策略 A（推荐）：`script_length?: ScriptLengthOption | LegacyScriptLengthOption`，并提供归一化函数
    - 策略 B：仍保持 `ScriptLengthOption` 为新集合，遇到旧值时在运行时映射到新值后再写入



## 组件与交互改造（GenerateAdvancedConfigSection）

### 3) 替换“脚本长度”选项为 5 档条数范围（电影/短剧都展示）
- 文件：`frontend/src/components/projectEdit/GenerateAdvancedConfigSection.tsx`
- 任务：
  - 单选项从 3 个改为 5 个（15～20、30～40、40～60、60～80、80～100）
  - 每项展示清晰说明（建议包含“预计模型调用次数”）
    - 15～20 条（1 次模型）
    - 30～40 条（2 次模型）
    - 40～60 条（3 次模型）
    - 60～80 条（4 次模型）
    - 80～100 条（5 次模型）
  - 保留/更新提示文案（例如将“短篇建议”替换为“短视频建议选择 15～20 条”等）

### 4) 抽离脚本长度的“读取+写回”逻辑（独立封装）
- 目标：符合工程化与低耦合，减少组件体积与副作用复杂度
- 任务拆分建议
  - 在组件内抽取纯函数：
    - `loadProjectScriptLength(projectId) -> Promise<ScriptLengthOption>`
    - `saveProjectScriptLength(projectId, value) -> Promise<void>`
  - 或抽为自定义 hook（优先复用，不强制新增文件）：
    - `useProjectScriptLength(projectId)` 返回 `{ scriptLength, setScriptLengthAndPersist, loading }`
- 行为要求
  - 初次加载：读取项目并归一化后设置 state
  - 切换选项：先本地更新 UI，再异步写回；失败时给出提示并回滚或保持（需统一交互策略）

### 5) 兼容旧值的 UI 展示策略
- 任务：
  - 若读取到旧值：
    - 映射到一个新值并选中
    - 建议：用户一旦切换或点击保存时，写回新值，完成迁移
    - 可选：在旁边展示轻量提示（例如“该项目使用旧配置，已自动转换为 X”）
  - 若读取到未知值：
    - 回退到默认值（建议默认 `30～40条`）
    - 并在控制台/Toast 提示“配置异常已重置”（避免静默错误难排查）

## 与生成流程的联动（前端层面）
- 前端无需参与“字幕拆分/模型调用次数”计算（由后端执行），但需要保证：
  - 用户选择能够在点击“生成脚本”前持久化到项目
  - 若用户切换后立刻点击生成，避免出现“保存尚未完成导致后端读取旧值”的竞态
- 任务：
  - 在点击“生成脚本”前确保 `updateProject` 已完成（或引入前端队列/防抖策略）
  - 生成中禁用切换（可选）：避免生成过程中用户改配置导致结果不可预期

## 自测清单（前端手工验证）
- 回显与保存
  - 进入电影/短剧项目编辑页：脚本条数选择正确回显
  - 切换任意条数范围：刷新页面仍能回显相同选项
- 兼容旧值
  - 后端返回 `script_length="短篇"`：页面不报错，能显示一个合理的新选项，并可再次保存为新值
- 竞态与失败处理
  - 网络较慢时快速切换并点击生成：最终后端使用的是用户最后一次选择
  - updateProject 失败：UI 有明确提示，且不会让用户误以为已保存成功
