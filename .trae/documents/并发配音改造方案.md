## 背景与现状
- 当前并发控制只作用在“项目级任务”（generate_video / generate_jianying_draft）入队与 worker 数量上：[task_scheduler.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/modules/task_scheduler.py) + [project_routes.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/routes/project_routes.py)。
- “配音片段”在任务内部 for 循环里 `await tts_service.synthesize(...)` 串行执行，因此 16 段配音也只有 1 路在跑：[jianying_draft_manager.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/services/jianying_draft_manager.py) / [video_generation_service.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/services/video_generation_service.py)。

## 改造目标
- 将并发的控制点从“项目任务并发”下沉到“配音片段并发”。
- 统一用配置控制配音并发上限，默认保守，避免第三方限流/GPU/CPU过载。
- 保持取消、失败可定位、WebSocket 进度可用。
- 移除 allow_same_project_parallel：同一项目同一 scope 下不再允许并行重复任务。

## 总体方案（推荐）
- 保持 TaskScheduler 负责“项目级任务”排队与取消。
- 在 tts_service 层加入“全局配音并发闸门”（Semaphore），所有 synthesize 统一限流。
- 在生成任务内部把“配音片段”改为有限并发调度（并发只覆盖 TTS 阶段，ffmpeg 等重操作继续串行）。

## 具体改造点
1) 移除 allow_same_project_parallel（配置 + 调度器 + 路由）
- 配置层：从 [generate_concurrency_config.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/modules/config/generate_concurrency_config.py) 删除字段 allow_same_project_parallel，并在 load 时兼容旧配置（忽略该字段）。
- 接口层：从 [generate_routes.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/routes/generate_routes.py) 删除 allow_same_project_parallel 的读写。
- 调度器：从 [task_scheduler.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/modules/task_scheduler.py) 的 enqueue 签名移除 allow_same_project_parallel 参数；dedup=True 时始终对同 project_id 去重（同项目同 scope 只保留一个任务）。
- 路由：从 [project_routes.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/routes/project_routes.py) 两个入队点移除 allow_parallel 相关逻辑与日志字段。

2) 新增“配音并发”配置（新增 scope：tts）
- 扩展 [generate_concurrency_config.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/modules/config/generate_concurrency_config.py)：
  - ScopeName 增加 tts（或 tts_synthesize）
  - GenerateConcurrencyConfig 增加 tts 的 max_workers/override
  - 支持 env 覆盖（例如 SACV_TTS_MAX_WORKERS）与 recommend_concurrency("tts")
- 扩展 [generate_routes.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/routes/generate_routes.py)：
  - /api/generate/concurrency 返回与更新包含 tts
  - resize 接口允许对 tts scope 调整（用于 TaskScheduler 或 tts_service 读取同一配置时的同步）

3) 在 tts_service 内做全局限流
- 在 [tts_service.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/modules/tts_service.py) 增加模块级 semaphore：
  - synthesize 入口 `async with tts_semaphore:`
  - semaphore 的并发数来源：generate_concurrency_config_manager.get_effective("tts")
  - 可选：按 provider 再细分一层 semaphore（先全局，再 provider），避免某个 provider 被打爆

4) 剪映草稿：并发生成配音（两阶段）
- 在 [jianying_draft_manager.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/services/jianying_draft_manager.py) 把现有 for 循环拆成：
  - 阶段 1：对所有需要配音的片段并发执行 TTS（受 tts_service semaphore 限制），产出音频文件与时长；用 `asyncio.as_completed` 广播 tts_progress。
  - 阶段 2：按原顺序串行执行 normalize + overlay + 对齐，生成 timeline_items。

5) 视频生成：并发生成配音（两阶段）
- 在 [video_generation_service.py](file:///Users/jiangchao/Documents/江汐瑶/学习/测试/superAIAutoCutVideo/backend/services/video_generation_service.py) 做同样拆分：
  - 先剪切片段（保留串行，稳定）
  - 并发生成需要配音的音频
  - 再串行按配音时长扩/缩 + replace_audio_with_narration

## 验证方式
- 构造 16 段均需配音的 segments：
  - 观察日志中 TTS 开始/结束时间交错（证明并发）
  - 观察 WebSocket 进度持续推进，最终 completed=100
- 配置切换：tts_max_workers=1/2/4/8 各跑一次，确认失败率与资源占用可接受

## 交付的 MD 文档
- 文件名（建议）：backend/docs/tts_concurrency_refactor.md
- 内容包含：现状问题、为什么“并发配置不生效”、方案 A 两阶段设计、配置项与 env、取消/进度、验证清单、回滚方式。

确认后执行顺序
- 先把上述 md 文档写入仓库。
- 再按“移除 allow_same_project_parallel → 新增 tts scope → tts_service 限流 → 两个生成流程两阶段并发 TTS”的顺序改代码并做一次最小化验证。